// === Знакомство с JavaScript ===
// Когда мы говорим о программировании, первое, что приходит в голову это набор инструкций в файле. Исходный код (source code) - это текст компьютерной программы на любом языке программирования, набор удобочитаемых синтаксических конструкций, описывающих набор инструкций для компьютера.

// Сам по себе исходный код непонятен для машины. Есть шаг, выполняющийся после написания программы, который конвертирует исходный код в файле в набор инструкций понятных компьютеру. Этим занимается специальная программа: компилятор или интерпретатор. Отсюда можно сделать вывод - код пишется не для машины, а для разработчика. Исходный код должен не только верно решать задачу, но и быть понятным.

// === Логическое мышлени ===
// В мире существует много языков программирования. Они не такие сложные, как человеческие, потому что состоят из довольно маленького набора синтаксических конструкций, а их принцип работы и базовые концепции похожи между разными языками.

// Опытные разработчики рассматривают проблемы с точки зрения алгоритмов - набора шагов, которые нужно выполнить для достижения определённой цели. Мы постоянно используем алгоритмы в повседневной жизни. Например, процесс приготовления чая - это набор необходимых шагов (алгоритм) для достижения результата. Когда вы привыкнете выстраивать решение задачи в виде алгоритма, язык программирования будет всего лишь инструментом.

// === JavaScript ===
// JavaScript - реализация спецификации EcmaScript, высокоуровневый язык программирования, поддерживаемый всеми современными веб-браузерами. Изначально предназначенный для взаимодействия с элементами веб-страниц и добавления интерактивности.

// ================================================================================================
// ИНТЕРЕСНО
// JavaScript не имеет никакого отношения к языку Java. Это два независимых языка программирования.
// ================================================================================================

// При Front-end разработке JavaScript используется в связке с HTML и CSS для обеспечения функциональности веб-страницы, такой как:

// несложные вычисления
// проверка и манипуляция введёнными пользователем данными
// хранение информации в браузере пользователя
// динамическое изменение HTML-документа
// реакция на действия пользователя
// создание интерактивных элементов: галерей, графиков и т. п.
// взаимодействие с бэкендом

// ================================================================================================
// ИНТЕРЕСНО
// Если JavaScript-код пишется для исполнения в браузере (Front-end), у разработчика нет инструментов и доступа к файловой или операционной системе по соображениям безопасности.
// ================================================================================================

// На сегодняшний день используя JavaScript можно создавать:

// веб-приложения на фреймворках React, Vue, Angular и других
// бэкенд приложения на Node.js
// мобильные приложения на React Native или Ionic
// десктоп приложения с помощью Electron
// микроконтроллеры с Johnny-Five и Espruino
// Для реализации всех этих возможностей необходимо хорошо знать синтаксис языка, его особенности и механизмы, тренироваться мыслить алгоритмически и решать как можно больше практических задач.

// === Подключение скрипта ===
// Чтобы добавить скрипт на веб-страницу в HTML-файле используется тег script, в атрибуте src которого указываем ссылку на внешний JavaScript-файл.

// Чтобы подключить JavaScript из внешнего файла:

// Создайте файл с расширением .js и поместите его в подпапку js.
// Затем укажите путь к файлу скрипта в атрибуте src тега script.
// <!DOCTYPE html>
// <html lang="en">
//   <head>
//     <meta charset="UTF-8" />
//     <title>JavaScript is fun!</title>
//   </head>

//   <body>
//     <!-- контент -->
//     <script src="js/script.js"></script>
//   </body>
// </html>

// ================================================================================================
// ИНТЕРЕСНО
// Размещение JavaScript файла в папке js не требуется, однако это хорошая практика.
// ================================================================================================

// Если скрипт подключен в <head>, отрисовка страницы останавливается до тех пор, пока скрипт не загрузится и выполнится полностью. Браузер загружает и отображает HTML постепенно. Если он видит тег <script> без дополнительных атрибутов, то сначала выполняется скрипт и только потом обрабатывается остальной код HTML-файла. Поэтому скрипт подключают перед закрывающим тегом <body> после всего содержимого, как в примере.

// === Несколько скриптов ===
// При подключении нескольких JavaScript-файлов к странице, интерпретатор обрабатывает их в том порядке, в котором они указаны в HTML-файле.

// <script src="js/script-1.js"></script>
// <script src="js/script-2.js"></script>

// === Инструменты разработчика ===
// При написании кода всегда будут оповещения и ошибки, это нормально. Консоль браузера показывает информацию связанную с веб-страницей, в том числе сообщения об ошибках и предупреждения исполнения JS-кода, запущенного в контексте страницы.

// Следующие комбинации клавиш открывают инструменты разработчика на вкладке Console:

// Windows и Linux - Ctrl + Shift + J или F12
// MacOS - Command + Option + J

// === Дополнительные материалы ===
// Вывод сообщений в консоль(https://developer.chrome.com/docs/devtools/console/log/)
// Справочник по API консоли(https://developer.chrome.com/docs/devtools/console/api/)


// === Основы синтаксиса ===
// При написании кода важно не просто знать какой символ или конструкцию можно использовать, но в первую очередь необходимо понимать терминологию и составляющие исходного кода. В этой секции нам не важно понимание как что работает, мы лишь познакомимся с базовой терминологией и синтаксисом.

// === Инструкция ===
// Инструкция (statement) - это связанный набор слов и символов из синтаксиса языка, которые объединяются чтобы выразить одну идею, одну инструкцию для машины.

// a = b * 2;

// Инструкции в JavaScript заканчиваются точкой с запятой, которую можно сравнить с точкой в конце предложения вашего родного языка.

// a и b - переменные (как в алгебраическом уравнении), это хранилища данных, которые использует программа. Переменная состоит из идентификатора (имени) и связанного с ним значения.
// 2 - просто число. Это называется значением литерала (literal value), так как не хранится в переменной.
// = и * - операторы, производят действия над значениями и переменными.
// Представим, что переменная b уже хранит число 10. Тогда эта инструкция говорит машине:

// Пойди найди переменную с идентификатором b и спроси какое у нее сейчас значение.
// Подставь значение переменной b (10) в утверждение на место b.
// Выполни операцию умножения 10 на 2.
// Запиши результат вычисления выражения правой части в переменную a.

// ================================================================================================
// ИНТЕРЕСНО
// Завершение инструкции точкой с запятой не требуется, однако настоятельно рекомендуется всегда её ставить. Это простое правило сделает код более понятным и поможет избежать неочевидных ошибок.
// ================================================================================================

// === Выражение ===
// Инструкции состоят из частей, как в любом языке предложения состоят из фраз, и эти фразы называются выражениями.

// Выражение (expression) - ссылка на переменную или значение, или на набор переменных и значений в сочетании с операторами.

// [ [a] = [ [b] * [2] ] ]

// Инструкция из примера выше содержит 5 выражений, которые выделены квадратными скобками для визуализации (это не синтаксис языка):

// [2] - выражение значения литерала.
// [b]и[a] - выражения переменной, означают необходимость подставить значение переменной, но только в том случае, если переменная стоит в правой части выражения присваивания.
// [b * 2] - арифметическое выражение умножения.
// [a = b * 2] - выражение присваивания. В нашем случае указывает на необходимость вычисления правой части выражения и присваивания результата переменной a в левой части выражения.
// Также есть выражения вызова, сравнения и т. д. Мы не будем сейчас рассматривать их все, нам важно понимать, из каких частей состоит исходный код, и как правильно его читать.

// === Интерфейс ===
// Когда мы подходим к автомату с кофе или садимся за руль автомобиля, существует некоторый набор элементов управления с которым можно взаимодействовать. В программировании это называется интерфейс.

// Интерфейс - это набор свойств и методов сущности, доступных для использования в исходном коде.

// === Свойство ===
// У нас с вами есть свойства: рост, вес, цвет глаз, то есть какие-то описательные характеристики. Так же и у данных есть свойства, например у строки есть свойство ее длины. Синтаксис обращения к свойству очень простой - через точку.

// сущность.имя_свойства

// Для наглядности обратимся к свойству строки length, которое содержит кол-во символов строки.

// "JavaScript is awesome".length;

// === Метод ===
// Это вызов действия, например присесть или плавать, то есть какая-то активная операция. Так же и у данных есть свои заранее определённые методы, например можно добавить или удалить элементы из коллекции, перевести строку в разный регистр и т. д. Синтаксис вызова метода очень похож на обращение к свойству, но в конце добавляется пара круглых скобок.

// сущность.имя_метода()

// Для примера обратимся к методу строки toUpperCase(), который сделает все буквы заглавными.

// "JavaScript is awesome".toUpperCase();
// console.log('JavaScript is awesome'.toUpperCase()) - верхний регистр
// console.log('JavaScript is awesome'.toLowerCase()) - нижний регистр

// === Строгий режим ===
// Новая возможность в спецификации ECMAScript 5, которая позволяет переводить скрипт в режим полного соответствия современному стандарту. Это предотвращает определенные ошибки, такие как использование небезопасных и устаревших конструкций.

// Для того, чтобы перевести скрипт в строгий режим, достаточно указать директиву в начале js-файла. Всегда пишите код в строгом режиме.

// script.js

// "use strict";
// Это комментарий. Дальше идет весь код JS-файла


// === Переменные и типы ===
// Переменные используются для хранения данных и состоят из идентификатора (имени) и области в памяти, где хранится их значение. Переменную можно представить как коробку с названием, в которой что-то лежит (значение).

// <ключевое_слово> <имя_переменной> = <значение>

// Имена переменных
// Идентификатор - это имя переменной, функции или класса. Состоит из одного или нескольких символов в следующем формате.

// Первым символом должна быть буква a-z или A-Z, символ подчеркивания _ или знак доллара $.
// Другие символы могут быть буквами a-z, A-Z, цифрами 0-9, подчеркиваниями _ и знаками доллара $.
// Идентификаторы чувствительны к регистру. Это значит, что переменные user, usEr и User различны.
// Имя переменной должно быть понятным.

// # ❌ Плохо
// chislo
// korzina_tovarov
// profil_polzovatelya
// tekushiy_mesyaz

// # ✅ Хорошо
// number
// cart
// userProfile
// currentMonth

// Использование camelCase-нотации для идентификаторов это стандарт. Первое слово пишется строчными буквами, а каждое последующее начинается с заглавной. Например, user, greetUser, getUserData, isActive, activeGuestCount, totalWorkerSalary.

// Как называть переменные
// Соглашения об именах переменных
// Ключевые слова
// Есть список зарезервированных ключевых слов, которые имеют специальное значение и используются для определенных конструкций. Нельзя использовать ключевые слова как идентификаторы.

// abstract	  arguments	  await	        boolean
// break	  byte	      case	        catch
// char	      class	      const	        continue
// debugger	  default	  delete	    do
// double	  else	      enum	        eval
// export	  extends	  false	        final
// finally	  float	      for	        function
// goto	      if	      implements	import
// in	      instanceof  int	        interface
// let	      long	      native	    new
// null	      package	  private	    protected
// public	  return	  short	        static
// super	  switch	  synchronized	this
// throw	  throws	  transient	    true
// try	      typeof	  var	        void
// volatile	  while	      with	        yield


// === Объявление переменных ===
// Объявление переменной начинается с ключевого слова const. Такая переменная должна быть сразу инициализирована значением, после чего его нельзя переопределить.

// Переменные, объявленные как const, обязательно должны быть инициализированы значением во время объявления, иначе будет ошибка!!!

// const yearOfBirth = 2006;
// console.log(yearOfBirth); // 2006

// Если переменная объявлена как const, перезаписать ее значение нельзя. При попытке присвоить новое значение будешь ошибка выполнения скрипта!!!

// yearOfBirth = 2020; // ❌ Неправильно, будет ошибка

// Для того, чтобы объявить переменную, которой в будущем можно будет присвоить новое значение, используется ключевое слово let.

// Переменным, объявленным через let, не обязательно сразу присваивать значение.

// let age;

// Если переменной, объявленной как let, изначально не присвоено значение, она инициализируется специальным значением undefined (не определено)!!!

// console.log(age); // undefined

// console.log() это метод для вывода данных в консоль браузера, более детально с ним познакомимся позже.

// Если переменная объявлена как let, её значение можно перезаписать.

// age = 14;
// console.log(age); // 14

// ================================================================================================
// ИНТЕРЕСНО
// Объявление переменной без ключевого слова let или const приведет к ошибке, если скрипт выполняется в строгом режиме.
// ================================================================================================

// === Когда использовать const и let ===
// Единственное отличие const и let состоит в том, что const запрещает повторное присваивание переменной какого-либо значения. Объявление const делает код более читаемым, так как переменная всегда ссылается на одно и то же значение. В случае с let такой уверенности нет.

// Будет разумно использовать let и const так:

// Используйте const по умолчанию, большинство переменных будут объявлены именно так.
// Используйте let если потребуется присвоить переменной другое значение во время выполнения скрипта.


// === константы и КОНСТАНТЫ ===
// Имена КОНСТАНТ - переменных, значение которых не изменяется никогда на протяжении работы всего скрипта, обычно записываются в формате UPPER_SNAKE_CASE.

// Константа хранящая значение цвета
// const COLOR_TEAL = "#009688";

// Константа хранящая сообщение о результате логина
// const LOGIN_SUCCESS_MESSAGE = "Добро пожаловать!";

// Абсолютное большинство переменных – константы в другом смысле, они просто не изменяют значение после присвоения. Но при разных запусках скрипта, это значение может быть разным. Имена таких переменных записывают используя формат camelCase.

// === Обращение к переменной ===
// Важно различать неопределенные и необъявленные переменные.

// Неопределенная (undefined) - это переменная, которая была объявлена ключевым слово let, но не инициализирована значением. По умолчанию ей присваивается начальное значение undefined.

// let username;
// console.log(username); // undefined

// Необъявленная (undeclared(незадекларированный) или not defined(не определено)) - это переменная, которая не была объявлена в доступной области видимости. Попытка обратиться к пременной до её объявления вызовет ошибку. Например, чтобы прочитать или изменить её значение.

// ❌ Неправильно, будет ошибка
// age = 15; // ReferenceError: Cannot access 'age' before initialization(Справочная ошибка: невозможно получить доступ к «возрасту» перед инициализацией)
// console.log(age); // ReferenceError: age is not defined(возраст не определен)

// Объявление переменной age
// let age = 20;

// ✅ Правильно, обращаемся после объявления
// age = 25;
// console.log(age); // 25

// === Примитивные типы ===
// В JavaScript переменная не ассоциируется с каким-либо типом данных, тип есть у её значения. То есть переменная может хранить значения разных типов.

// === Number - целые числа и числа с плавающей запятой (точкой).

// const age = 20;
// const points = 15.8;
// console.log(age);
// console.log(points);

// === String - строки, последовательность из нуля или более символов. Строка начинается и заканчивается одиночной ', или двойными кавычками ".

// const userName = "Mango";
// const description = "JavaSript для начинающих";
// console.log(userName);
// console.log(description);

// === Boolean - логический тип данных, флаги состояния. Всего два значения: true и false. Например, на вопрос включен ли свет в комнате можно ответить да (true) или нет (false).

// true — да, верно, истина, 1
// false — нет, неверно, ложь, 0
// Обратите внимание на имена переменных, содержащих буль. Они задают вопрос, и ответ на его - да или нет.

// const isLoggedIn = true;
// const canMerge = false;
// const hasChildren = true;
// const isModalOpen = false;

// === null - особое значение, которое по сути значит ничто. Используется в тех ситуациях, когда необходимо явно указать пустоту. К примеру если пользователь ещё ничего не выбрал, то можно сказать что значение null.

// let selectedProduct = null;

// === undefined - ещё одно специальное значение. По умолчанию, когда переменная объявляется, но не инициализируется, ее значение не определено, ей присваивается undefined.

// let username;
// console.log(username); // undefined

// === Оператор typeof ===
// Используется для получения типа значения переменной. Возвращает на место своего вызова тип значения переменной указанного после него - строку в которой указан тип.

// let username;
// console.log(typeof username); // "undefined"

// let inputValue = null;
// console.log(typeof inputValue); // "object"

// const quantity = 17;
// console.log(typeof quantity); // "number"

// const message = "JavaScript is awesome!";
// console.log(typeof message); // "string"

// const isSidebarOpen = false;
// console.log(typeof isSidebarOpen); // "boolean"


// === Взаимодействие с пользователем ===
// Разберем базовые операции ввода/вывода, достаточные для получения и отображения данных от пользователя, до того как научимся работать с HTML-документом.

// === Вывод данных ===
// Для вывода данных есть два метода: console.log() и alert(). В круглых скобках указываем имя переменной, значение которой необходимо вывести.

// const message = "JavaScript is awesome!";
// console.log(message); // JavaScript is awesome!

// Можно сначала указать какую-то описательную строку, после чего поставить запятую и указать имя переменной.

// const userName = "Mango";
// console.log("Username is", userName); // Username is Mango

// Метод alert() выводит модальное окно, текст которого соответствует значению переменной (или литерала) которую передадим в скобках.

// const message = "JavaScript is awesome!";
// alert(message);

// ================================================================================================
// ИНТЕРЕСНО
// console и alert являются частью интерфейса window - глобального объекта, доступного при исполнении скрипта на веб-странице. Запись window.alert() избыточна, пишем просто alert() или console.log(). Детальнее об этом будем говорить дальше в курсе.
// ================================================================================================

// Going beyond console.log() (https://medium.com/free-code-camp/how-to-use-the-javascript-console-going-beyond-console-log-5128af9d573b)

// === Получение данных ===
// Для получения данных от пользователя есть prompt() и confirm(). Это тоже методы из интерфейса window. Результатом своего выполнения они возвращают то, что было введено пользователем, поэтому результат их работы можно записать в переменную для дальнейшего использования.

// confirm() - выводит модальное окно с сообщением, и две кнопки, Ok и Cancel. При нажатии на Ok, результатом будет true, при нажатии на Cancel - возвращается false.

// Просим клиента подтвердить бронь на отель и сохраняем в переменную результат работы confirm
// const isComing = confirm("Please confirm hotel reservation");
// console.log(isComing);

// prompt() - выводит модальное окно с полем ввода и кнопками Ok и Cancel. При нажатии Ok, результатом будет то, что ввел пользователь, при Cancel - возвращается null.

// Спрашиваем имя отеля в котором хотел бы остановится клиент и сохраняем в переменную результат вызова prompt.
// const hotelName = prompt("Please enter desired hotel name");
// console.log(hotelName);

// Важная особенность prompt в том, что не зависимо что ввел пользователь, всегда вернется строка. То есть, если пользователь ввел 5, то вернется не число 5, а строка "5".

// const value = prompt("Please enter a number!");
// console.log(typeof value); // "string"
// console.log(value); // "5"


// === Основные операторы ===
// === Математические операторы ===
// Назначение, функционал и приоритет (порядок) операций ничем не отличаются от школьного курса алгебры. Операторы возвращают значение как результат выражения.

// const x = 10;
// const y = 5;

// Сложение
// console.log(x + y); // 15

// Вычитание
// console.log(x - y); // 5

// Умножение
// console.log(x * y); // 50

// Деление
// console.log(x / y); // 2

// Остаток от деления
// console.log(x % y); // 0

// Сложение с заменой (также есть для всех других операторов)
// let value = 5;

// Аналогично записи value = value + 10;
// value += 10;
// console.log(value); // 15

// ================================================================================================
// ИНТЕРЕСНО
// Важно запомнить термины составляющих выражения. + - * / % называются операторы, а то, на чем они применяются - операнды.
// ================================================================================================

// Операторы сравнения
// Используются для сравнения двух значений. Результатом своего выполнения возвращают буль - true или false, то есть «да» или «нет».

// a > b и a < b - больше/меньше
// a >= b и a <= b - больше/меньше или равно
// a == b - равенство
// a != b - неравенство
// a === b - строгое равенство
// a !== b - строгое неравенство
// const x = 5;
// const y = 10;
// const z = 5;

// console.log("x > y:", x > y); // false
// console.log("x < y:", x < y); // true
// console.log("x < z:", x < z); // false
// console.log("x <= z:", x <= z); // true
// console.log("x === y:", x === y); // false
// console.log("x === z:", x === z); // true
// console.log("x !== y:", x !== y); // true
// console.log("x !== z:", x !== z); // false

// Операторы равенства
// «Нестрогие» операторы равенства == и != выполняют преобразование типов сравниваемых значений к числу, что может привести к ошибкам, особенно у начинающих.

// ❌ Плохо, выполняется приведение типов
// console.log(5 == "5"); // true
// console.log(5 != "5"); // false
// console.log(1 == true); // true
// console.log(1 != true); // false

// Поэтому для проверки равенства или неравенства двух значений используются только операторы === (строгое равенство) и !== (строгое неравенство), которые не выполняют приведение типов операндов.

// ✅ Хорошо, приведение типов не выполняется
// console.log(5 === "5"); // false
// console.log(5 === 5); // true
// console.log(5 !== "5"); // true
// console.log(5 !== 5); // false
// console.log(1 === true); // false
// console.log(1 !== true); // true

// В таком случае, все равно только себе. Перед оценкой ничего не преобразуется.


// === Числа ===
// Все числа в JavaScript, как целые так и дробные, имеют тип Number и записывать их можно не только в десятичной системе счисления.

// === Приведение к числу ===
// Большинство арифметических операций и математических функций преобразуют значение в число автоматически. Для того чтобы сделать это явно, используйте функцию Number(val), передавая ей в val то, что надо привести к числу.

// Если значение не возможно привести к числу, результатом будет специальное числовое значение NaN (Not a Number). Аналогичным образом происходит преобразование и в других математических операторах и функциях.

// const valueA = "5";
// console.log(Number(valueA)); // 5
// console.log(typeof Number(valueA)); // "number"

// const valueB = "random string";
// console.log(Number(valueB)); // NaN
// console.log(typeof Number(valueB)); // "number"

// === Методы Number.parseInt() и Number.parseFloat()
// Преобразуют строку символ за символом, пока это возможно. При возникновении ошибки возвращается число, которое получилось.

// === Метод Number.parseInt() парсит из строки целое число.

// console.log(Number.parseInt("5px")); // 5
// console.log(Number.parseInt("12qwe74")); // 12
// console.log(Number.parseInt("12.46qwe79")); // 12
// console.log(Number.parseInt("qweqwe")); // NaN

// === Метод Number.parseFloat() парсит из строки дробное число.

// console.log(Number.parseFloat("5px")); // 5
// console.log(Number.parseFloat("12qwe74")); // 12
// console.log(Number.parseFloat("12.46qwe79")); // 12.46
// console.log(Number.parseFloat("qweqwe")); // NaN

// === Проверка на число ===
// Для проверки на число можно использовать метод Number.isNaN(val). Он проверяет, является ли указанное значение NaN или нет. Метод отвечает на вопрос "Это Not A Number?" и возвращает:

// true - если значение val это NaN
// false - если значение val это не NaN
// Для всех значений val кроме NaN, при передаче в Number.isNaN(val) вернёт false. Этот метод не производит попытку преобразовать val к числу, а просто выполняет проверку на NaN.

// const validNumber = Number("51"); // 51
// console.log(Number.isNaN(validNumber)); // false

// const invalidNumber = Number("qweqwe"); // NaN
// console.log(Number.isNaN(invalidNumber)); // true


// === Сложение чисел с плавающей точкой ===
// При сложении не целых чисел в JavaScript и других языках программирования, есть особенность. Если кратко, то 0.1 + 0.2 не равно 0.3, результат сложения больше чем 0.3. Все от того что машина считает в двоичной системе.

// Число 0.1 в двоичной системе счисления - это бесконечная дробь, так как единица на десять в двоичной системе не делится. Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. При сложении 0.1 и 0.2, две неточности складываются, получается незначительная, но всё же ошибка в вычислениях.

// console.log(0.1 + 0.2 === 0.3); // false
// console.log(0.1 + 0.2); // 0.30000000000000004

// Конечно, это не означает, что точные вычисления для таких чисел невозможны. Есть несколько методов решения этой проблемы.

// Можно сделать их целыми, умножив на N, сложить, а потом результат разделить также на N.

// console.log(0.17 + 0.24); // 0.41000000000000003
// console.log((0.17 * 100 + 0.24 * 100) / 100); // 0.41

// Еще один способ - сложить, а результат отсечь до определённого знака после запятой при помощи метода toFixed().

// console.log(0.17 + 0.24); // 0.41000000000000003
// console.log((0.17 + 0.24).toFixed(2)); // 0.41

// === Класс Math ===
// Один из встроенных классов, который предоставляет набор методов для работы с числами. Знание всех методов наизусть не требуется, только некоторых, наиболее полезных.

// Math.floor(num) - возвращает наибольшее целое число,
// меньшее, либо равное указанному
// console.log(Math.floor(1.7)); // 1

// Math.ceil(num) - возвращает наименьшее целое число,
// большее, либо равное указанному числу.
// console.log(Math.ceil(1.2)); // 2

// Math.round(num) - возвращает значение числа,
// округлённое до ближайшего целого
// console.log(Math.round(1.2)); // 1
// console.log(Math.round(1.5)); // 2

// Math.max(num1, num2, ...) - возвращает наибольшее число из набора
// console.log(Math.max(20, 10, 50, 40)); // 50

// Math.min(num1, num2, ...) - возвращает наименьшее число из набора
// console.log(Math.min(20, 10, 50, 40)); // 10

// Math.pow(base, exponent) - возведение в степень
// console.log(Math.pow(2, 4)); // 16

// Math.random() - возвращает псевдослучайное число в диапазоне [0, 1)
// console.log(Math.random()); // случайное число между 0 и 1
// console.log(Math.random() * (10 - 1) + 1); // псевдослучайное число от 1 до 10


// === Строки ===
// Строка - это индексированный набор из нуля или более символов, заключенных в одинарные' либо двойные" кавычки.

// const username = "Mango";

// Важно помнить, что индексация элементов строки начинается с нуля. К примеру в строке "JavaScript" буква "J" стоит на позиции с индексом 0, а "t" идет под индексом 9.

// position ----- 1 2 3 4 5 6 7 8 9 10
//                J a v a S c r i p t
// index -------- 0 1 2 3 4 5 6 7 8 9

// Содержимое строки нельзя изменить, только прочитать. То есть нельзя взять какой-то символ и заменить его, как только строка создана - она такая навсегда. Можно лишь создать целиком новую строку и присвоить в переменную вместо старой.

// === Конкатенация строк ===
// Если применить оператор + к строке и любому другому типу данных, результатом операции «сложения» будет строка. Эта операция называется конкатенация, или сложение строк.

// Во время конкатенации, любой тип данных приводится к строке и сшивается со строкой, но есть особенность - последовательность записи операндов.

// Последовательность операций имеет значение, преобразование типов происходит только в момент операции сложения со строкой, до этого момента действуют привычные правила математики.

// const message = "Mango " + "is" + " happy";
// console.log(message); // Mango is happy

// Посмотрим на разный порядок операндов.

// console.log(1 + "2"); // "12"
// console.log(1 + "2" + 4); // "124"
// console.log(1 + 2 + "4"); // "34"

// В последнем примере произошла математическая операция сложения для первых двух чисел 1 и 2, после чего число 3 было преобразовано в строку "3" и сшито со строкой "4".

// === Шаблонные строки ===
// Шаблонные строки это альтернатива конкатенации с более удобным синтаксисом. Шаблонная строка заключена в обратные (косые) кавычки вместо двойных или одинарных и может содержать местозаполнители, которые обозначаются знаком доллара и фигурными скобками - ${выражение}.

// Используя переменные необходимо составить строку с подставленными значениями
// const guestName = "Манго";
// const roomNumber = 207;
// const greeting ="Welcome " + guestName + ", your room number is " + roomNumber + "!";
// console.log(greeting); // "Welcome Mango, your room number is 207!"

// Составлять строки с подставляемыми значениями используя конкатенацию очень неудобно. На помощь приходят шаблонные строки и интерполяция.

// const guestName = "Манго";
// const roomNumber = 207;
// const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
// console.log(greeting); // "Welcome Mango, your room number is 207!"

// === Свойства и методы строк ===
// У каждой строки есть встроенные свойства и методы, рассмотрим некоторые из них.

// === Свойство length ===
// Для того чтобы узнать длину строки, то есть количество её символов, у всех строк есть встроенное свойство length, значение которого можно получить обратившись к нему через точку после имени переменной или строкового литерала.

// const message = "Welcome to Bahamas!";
// console.log(message.length); // 19
// console.log("There is nothing impossible to him who will try".length); // 47

// === Методы toLowerCase() и toUpperCase() ===
// Возвращают новую строку в соответствующем регистре, не изменяя оригинальную строку.

// const message = "Welcome to Bahamas!";
// console.log(message.toLowerCase()); // "welcome to bahamas!"
// console.log(message.toUpperCase()); // "WELCOME TO BAHAMAS!"
// console.log(message); // "Welcome to Bahamas!"

// Бывают ситуации когда все символы в строке необходимо преобразовать в один регистр, верхний или нижний. Например, при поиске по ключевому слову, когда пользователь вводит строку 'saMsUng', а сравнить её надо со строкой 'samsung' или 'SAMSUNG'.

// console.log("saMsUng" === "samsung"); // false
// console.log("saMsUng" === "SAMSUNG"); // false

// Чтобы не требовать абсолютно точный ввод можно сделать «нормализацию» введённой пользователем строки, то есть преобразовать все её символы в верхний или нижний регистр. Методы строки toLowerCase() и toUpperCase() вернут новую строку в соответствующем регистре, не изменяя оригинальную.

// const BRAND_NAME = "SAMSUNG";
// const userInput = "saMsUng";
// const normalizedToUpperCaseInput = userInput.toUpperCase();

// console.log(userInput); // 'saMsUng'
// console.log(userInput === BRAND_NAME); // false
// console.log(normalizedToUpperCaseInput); // 'SAMSUNG'
// console.log(normalizedToUpperCaseInput === BRAND_NAME); // true

// === Метод indexOf() ===
// Возвращает позицию (индекс) на которой находится первое совпадение подстроки или -1, если ничего не найдено.

// const message = "Welcome to Bahamas!";
// console.log(message.indexOf("to")); // 8
// console.log(message.indexOf("hello")); // -1

// === Метод includes() ===
// Проверяет входит ли подстрока в строку, возвращает буль - true если входит и false в противном случае. Регистр символов в строке и подстроке имеет значение, так как например буква "a" не равна букве "А".

// const productName = "Ремонтный дроид";

// console.log(productName.includes("н")); // true
// console.log(productName.includes("Н")); // false
// console.log(productName.includes("дроид")); // true
// console.log(productName.includes("Дроид")); // false
// console.log(productName.includes("Ремонтный")); // true
// console.log(productName.includes("ремонтный")); // false

// ================================================================================================
// ИНТЕРЕСНО
// Все методы строк чувствительны к регистру!!!
// ================================================================================================

// === Метод endsWith() ===
// Позволяет определить, заканчивается ли строка символами (подстрокой) указанными в скобках, возвращая true или false.

// const jsFileName = "script.js";
// console.log(jsFileName.endsWith(".js")); // true

// const cssFileName = "styles.css";
// console.log(cssFileName.endsWith(".js")); // false

// === Методы replace() и replaceAll() ===
// Возвращают новую строку, в которой первое (replace) или все совпадения (replaceAll) подстроки заменены на указанное значение.

// const jsFileName = "script.js";
// const minifiedJsFileName = jsFileName.replace(".js", ".min.js");
// console.log(minifiedJsFileName); // "script.min.js"

// const cssFileNames = "styles.css, about.css, portfolio.css";
// const minifiedCssFileNames = cssFileNames.replaceAll(".css", ".min.css");
// console.log(minifiedCssFileNames); // "styles.min.css, about.min.css, portfolio.min.css"

// === Метод slice() ===
// Метод строк slice(startIndex, endIndex) используется для создания копии части или всей строки. Он делает копию элементов строки от startIndex и до, но не включая endIndex и возвращает новую строку, не изменяя оригинал.

// const productName = "Repair droid";
// console.log(productName.slice(0, 4)); // "Repa"
// console.log(productName.slice(3, 9)); // "air dr"
// console.log(productName.slice(0, productName.length)); // "Repair droid"
// console.log(productName.slice(7, productName.length)); // "droid"


// === Логические операторы ===
// Логические операторы используются для проверки условий с множественными выражениями, например в операциях сравнения.

// === Приведение типов ===
// В логических операциях осуществляется приведение типов операндов к true или false. Приведение происходит если в коде обнаружен логический оператор.

// Truthy и Falsy - термины, которые используются для тех значений, которые, в логической операции, приводятся к true или false, хотя изначально не были булями.

// ================================================================================================
// ИНТЕРЕСНО
// Запомните 6 ложных (falsy) значений, приводящихся к false в логическом преобразовании: 0, NaN, null, undefined, пустая строка и false. Абсолютно все остальное приводится к true.
// ================================================================================================

// === Логические операторы ===
// Есть три логических оператора, которые используются для проверки выполнения множественных выражений.

// === Логическое «И» ===
// Оператор && приводит все операнды к булю и возвращает значение одного из них. Левый операнд если его можно привести к false, и правый в остальных случаях.

// выражение && выражение

// В следующем примере оба условия вернут true, поэтому результатом всего выражения будет true - вернётся значение правого операнда.

// const age = 20;
// console.log(age > 10 && age < 30); // true && true -> true

// Если хотябы один из операндов будет приведён к false, результатом выражения будет его значение.

// const age = 50;
// console.log(age > 10 && age < 30); // true && false -> false
// console.log(age > 80 && age < 120); // false && true -> false

// То есть логическое «И» запинается на лжи и возвращает то на чём запнулось или последний операнд.

// console.log(1 && 5); // true && true -> 5
// console.log(5 && 1); // true && true -> 1
// console.log(0 && 2); // false && true -> 0
// console.log(2 && 0); // true && false -> 0
// console.log("" && "Mango"); // false && true -> ""
// console.log("Mango" && ""); // true && false -> ""
// console.log("Mango" && "Poly"); // true && true -> "Poly"
// console.log("Poly" && "Mango"); // true && true -> "Mango"

// ================================================================================================
// ИНТЕРЕСНО
// При выполнении логического «И», правый операнд может не вычисляться, в случае если левый был приведен к false.
// ================================================================================================

// === Логическое «ИЛИ» ===
// Оператор || приводит все операнды к булю и возвращает значение одного из них. Левый операнд если его можно привести к true, и правый в остальных случаях.

// выражение || выражение

// В следующем примере условие слева вернёт true, поэтому результатом всего выражения будет true - вернётся значение первого операнда которое было приведено к true.

// const age = 5;
// console.log(age < 10 || age > 30); // true || false -> true

// Тут результатом тоже будет true, так как хотябы один из операндов, в этом случае правый, был приведён к true.

// const age = 40;
// console.log(age < 10 || age > 30); // false || true -> true

// А здесь ни одно из условий не выполняется, поэтому получаем false - значение последнего операнда.

// const age = 20;
// console.log(age < 10 || age > 30); // false || false -> false

// То есть логическое «ИЛИ» запинается на правде и возвращает то на чём запнулось или последний операнд.

// console.log(true || false); // true
// console.log(false || true); // true
// console.log(true || true); // true

// console.log(3 || false); // 3
// console.log(false || 3); // 3
// console.log(3 || true); // 3
// console.log(true || 3); // true

// ================================================================================================
// ИНТЕРЕСНО
// При выполнении логического «ИЛИ», правый операнд может не вычисляться, в случае если левый был приведен к true.
// ================================================================================================

// Логическое «НЕ»
// Все операторы которые мы рассматривали до этого были бинарными - содержащими два операнда, левый и правый. Логическое «НЕ» это унарный оператор - выполняющий операцию над одним операндом справа.

// !выражение

// Оператор ! приводит операнд к булю, если необходимо, а затем делает инверсию - заменяет его на противоположный true -> false или false -> true.

// console.log(!true); // false
// console.log(!false); // true
// console.log(!3); // !3 -> !true -> false
// console.log(!"Mango"); // !"Mango" -> !true -> false
// console.log(!0); // !0 -> !false -> true
// console.log(!""); // !"" -> !false -> true

// const isOnline = true;
// const isNotOnline = !isOnline; // !isOnline -> !true -> false

// Дополнительные материалы
// Logic Gates Explained (video) (https://www.youtube.com/watch?v=UvI-AMAtrvE)


// === SANDRA ===
// мультипарадигменный
// кроссплатформенный
// кроссбраузерный
// ES5 - 2009 и ES6 - 2015 ECMAScript
// слабая тимизация (динамическая)
// примитивы
// сложные

// === Variables ===
// === ES5
// var myFirstVar
// console.log('myFirstVar:', myFirstVar) // undefined

// === ES6
// let mySecondVar
// console.log('mySecondVar', mySecondVar) // undefined
// mySecondVar = 'var by let'
// console.log('mySecondVar:', mySecondVar) // Можно переписать

// const myThirdVar = 'variable by const'
// console.log(myThirdVar)
// myThirdVar = 'sfhjhsfgk' //НЕЛЬЗЯ переписать

// === Primitives (примитивные типы данных) & operator typeof ===
// console.log(undefined)
// console.log(typeof undefined) // undefined

// console.log('Sandra Hrevtsova')
// console.log(typeof 'Sandra ahrevtsova') // string

// console.log(100)
// console.log(typeof 100) // number

// console.log(true)
// console.log(typeof true) // boolean
// console.log(false)
// console.log(typeof false) // boolean

// console.log(null)
// console.log(typeof null) // object

// === сложные типы данных - объекты, массивы и функции ===

// === Приведение типов данных ===
// - к этим не приводятся данные!!!
// null
// undefined

// - а к этим типам можно привести любое значение!!!
// === string ===
let value
// console.log(value, typeof value) // undefined 'undefined'
// value = String(value)
// console.log(value, typeof value) // undefined string

// value = 777
// console.log(value, typeof value) // 777 'number'
// value = String(value)
// console.log(value, typeof value) // 777 string

// value = true
// console.log(value, typeof value) // true 'boolean'

// value = value + '' // конкатенация
// console.log(value, typeof value) // undefined string

// === number ===
// value = 'Hrevtsova'
// console.log(value, typeof value) // Hrevtsova string

// value = Number(value)
// console.log(value, typeof value) // NaN(Not a Number) 'number'

// value = '11'
// value = Number(value)
// console.log(value, typeof value) // 11 'number'

// value = false
// console.log(value, typeof value) // false 'boolean'

// value = +value
// console.log(value, typeof value) // 0 'number'

// value = true
// console.log(value, typeof value) // true 'boolean'

// value = Number(value)
// console.log(value, typeof value) // 1 'number'

// === boolean ===
// value = '' // '' = false
// console.log(value, typeof value) // string

// value = Boolean(value)
// console.log(value, typeof value) // false 'boolean'

// value = ' ' // true
// console.log(value, typeof value) // string

// value = Boolean(value)
// console.log(value, typeof value) // true 'boolean'

// value = 'Sandra'
// console.log(value, typeof value) // Sandra string

// value = Boolean(value)
// console.log(value, typeof value) // true 'boolean'

// value = 1 // true
// console.log(value, typeof value) // 1 'number'

// value = Boolean(value)
// console.log(value, typeof value) // true 'boolean'

// value = 0 // false
// console.log(value, typeof value) // 0 'number'

// value = Boolean(value)
// console.log(value, typeof value) // false 'boolean'

// value = NaN // false
// console.log(value, typeof value) // NaN 'number'

// value = Boolean(value)
// console.log(value, typeof value) // false 'boolean'

// value = null // false
// console.log(value, typeof value) // null 'object'

// value = Boolean(value)
// console.log(value, typeof value) // false 'boolean'

// value = undefined // false
// console.log(value, typeof value) // undefined 'undefined'

// value = Boolean(value)
// console.log(value, typeof value) // false 'boolean'

// value = false // false
// console.log(value, typeof value) // false 'false'

// value = Boolean(value)
// console.log(value, typeof value) // false 'boolean'

// === 6 falsy values ===
// console.log('false', '')
// console.log('false', 0)
// console.log('false', NaN)
// console.log('false', null)
// console.log('false', undefined)
// console.log('false', false)

// === взаимодействие с пользователем ===
// let response = alert('Hello!') // ok => undefined
// let response = confirm('Вам есть 18?') // if ok => true  else cancel (отмена) => false
// let response = prompt('Введите пожалуйста число') // if ok => value else cancel => null

// console.log(response)

// === основные операторы (матем и сравнения) ===
// console.log(1 + 1)
// console.log(2 - 1)
// console.log(3 * 4)
// console.log(10 / 2)

// console.log(2 ** 3) //возведение в степень
// console.log( 10 % 3) // остаток от деления

// console.log(2 > 4)
// console.log(2 >= 2)

// === не строгое равенство ===
// console.log("'1' == 1" , '1' == 1) // true
// string == number - true, потому что приведение типов произошло
// console.log('true == 1', true == 1)
// console.log('false == 0', false == 0)

// console.log("'5' == 1", '5' == 1) // false

// === не строгое неравенство ===
// console.log("'1' != 1" , '1' != 1) // false
// string != number - false, потому что приведение типов произошло и мы изменили результат на противоположный, благодаря !
// console.log('true != 1', true != 1) // false
// console.log('false != 0', false != 0) // false

// console.log("'5' != 1", '5' != 1) //true

// === строгое равенство ===
// console.log('1' === 1) // false
// string === number
// console.log(1 === 1) // true
// console.log('true === 1', true === 1)
// console.log('false === 0', false === 0)

// === строгое неравенство ===
// console.log('1' !== 1) // true
// string !== number
// console.log(1 !== 1) // false
// console.log('true !== 1', true !== 1) //true
// console.log('false !== 0', false !== 0) //true

// === строки ===
// console.log('Hello')
// console.log("Hello")
// console.log(`Hello`)

// === concat (конкатенация) ===
// let name = 'Sandra'
// let message = 'Hello, ' + name + ' We are glad to see you!'
// console.log(message)

// name = 'Anatolii'
// message = 'Hello, ' + name
// console.log(message)

// === `${}` - шаблонная строка и интерполяция ===
// message = `Hi, ${name}!`
// console.log(message)

// === toLowerCase() & toUpperCase() ===
// let nameInDB = 'hrevtsova'
// console.log(nameInDB.toUpperCase()) // GREVTSOVA

// let lastName = 'HREVTSOVA'
// console.log(lastName.toLowerCase()) // grevtsova

// === свойство .length ===
// console.log(lastName.length) // 9 - кол-во символов от 0

// === includes() & indexOf() ===
// const myLove = 'I Love JavaScript!!!'
// console.log(myLove)

// console.log(myLove.includes('Love')) // true
// console.log(myLove.includes('love')) // false

// console.log(myLove.indexOf('Love')) // 2 - index
// console.log(myLove.indexOf('love')) // -1 - если не нашол совпадения

// === числа ===
// === parseFloat & parseInt ===
// let weight = prompt('Укажи общий вес товара')
// console.log(weight, typeof weight)
// weight = parseFloat(weight) // берет дробное число из строки
// console.log(weight, typeof weight)

// weight = parseInt(weight) // берет целое число из строки
// console.log(weight, typeof weight)

// let price = 30
// let total = weight * price
// console.log('total', total)

// 0.1 + 0.2
// console.log(0.2 + 0.4)
// console.log(0.1 + 0.2 === 0.3) // false

// === 1 вариант
// console.log((0.1 * 10 + 0.2 * 10) / 10 === 0.3) //true
// === 2 вариант
// console.log(Number((0.1 + 0.2).toFixed(1)) === 0.3) //true

// === Math.ceil() - округляет до целого числа
// console.log(Math.ceil(0.1 + 0.2))

// === Math.floor() - отсекает все что после 0
// console.log(Math.floor(0.1 + 0.2))

// === Math.round() - округляет (до 5 после 0) к меньшему (после 5) к большему целому числу
// console.log(Math.round(0.1 + 0.2))
// console.log(Math.round(0.3 + 0.2))
